<?xml version="1.0" encoding="UTF-8"?>
<definitions xmlns="http://www.omg.org/spec/BPMN/20100524/MODEL"
             xmlns:flowable="http://flowable.org/bpmn"
             xmlns:bpmndi="http://www.omg.org/spec/BPMN/20100524/DI"
             xmlns:omgdc="http://www.omg.org/spec/DD/20100524/DC"
             xmlns:omgdi="http://www.omg.org/spec/DD/20100524/DI"
             targetNamespace="http://www.axians.com/eaf/dockets">

  <!--
    Story 6.6: Dockets Pattern BPMN Template

    This template replicates the legacy "Dockets Hook" pattern for DPCM/ZEWSSP migration:
    - PRESCRIPT: Pre-command automation (Ansible playbook)
    - CORECOMMAND: Business logic trigger (Axon command dispatch)
    - Event Wait: Wait for command completion (Axon event signal)
    - POSTSCRIPT: Post-command automation (Ansible playbook)
    - Error Boundary: Compensation for failures (reverse transaction)

    This pattern enables workflow orchestration while maintaining CQRS/Event Sourcing
    integrity and supports the NFR6 (Extensibility) requirement for PRESCRIPT/POSTSCRIPT hooks.

    Required Process Variables:
    - tenantId: String (MANDATORY - Tenant identifier for multi-tenant isolation)
    - prescriptPlaybookPath: String (Path to Ansible playbook for pre-command automation)
    - coreCommandClassName: String (Fully-qualified Axon command class name, e.g., "com.axians.eaf.api.widget.commands.CreateWidgetCommand")
    - coreCommandConstructorParameters: Map<String, Any> (Constructor arguments for command instantiation)
    - eventBusinessKey: String (Correlation key for AxonEventSignalHandler to match event to process instance)
    - postscriptPlaybookPath: String (Path to Ansible playbook for post-command automation)
    - compensationCommandClassName: String (Fully-qualified name of compensating command for error recovery)

    Output Variables (set by service tasks):
    - ansibleExitCode: Int (Exit code from Ansible playbook execution, 0 = success)
    - ansibleStdout: String (Standard output from playbook, truncated to 4KB for metadata size limits)
    - ansibleStderr: String (Standard error from playbook, truncated to 4KB)

    Internal Variables (set during error handling):
    - commandClassName: String (Current command class for DispatchAxonCommandTask, updated by SetCommandTypeDelegate during compensation)

    Security Requirements:
    - tenantId process variable MANDATORY for tenant isolation
    - All delegates enforce established command whitelists (com.axians.eaf.* package)
    - Error messages must not leak infrastructure details (CWE-209 protection)
    - See: docs/architecture/security.md
  -->

  <process id="dockets-pattern-template" name="Dockets Pattern Template" isExecutable="true">

    <documentation>
      Dockets Pattern Template - Legacy Workflow Migration

      This BPMN process replicates the legacy "Dockets Hook" pattern from DPCM/ZEWSSP:

      1. START: Process initiated with tenant context and configuration
      2. PRESCRIPT: Pre-command automation (Ansible playbook execution)
      3. CORECOMMAND: Business logic trigger (Axon command dispatch via CQRS)
      4. EVENT WAIT: Pause for command completion (Axon event signal)
      5. POSTSCRIPT: Post-command automation (Ansible playbook execution)
      6. ERROR BOUNDARY: Compensation for failures (reverse transaction via compensating command)
      7. END: Process completion (success or compensated)

      Legacy Dockets Pattern Mapping:
      - PRESCRIPT → Pre-command automation (infrastructure setup, validation)
      - CORECOMMAND → Business logic trigger (domain command dispatch)
      - EVENT WAIT → Command completion signal (async event notification)
      - POSTSCRIPT → Post-command automation (infrastructure finalization, notifications)

      This pattern enables migration of legacy Dockets workflows to modern BPMN/CQRS architecture
      while maintaining extensibility (NFR6) and tenant isolation (3-layer enforcement).
    </documentation>

    <!-- Element 1: Start Event -->
    <startEvent id="start" name="Start" />

    <!-- Element 2: Service Task - Ansible PRESCRIPT -->
    <serviceTask id="prescriptTask"
                 name="Ansible PRESCRIPT"
                 flowable:delegateExpression="${runAnsiblePlaybookTask}">
      <documentation>
        Executes pre-command automation Ansible playbook via SSH using RunAnsiblePlaybookTask delegate.

        Required Variables (from process start):
        - tenantId: Tenant identifier for isolation (MANDATORY)
        - playbookPath: Set to ${prescriptPlaybookPath} from process variables
        - inventory: (optional) Ansible inventory file
        - extraVars: (optional) Map of variables for playbook

        Output Variables (set by this task):
        - ansibleExitCode: Playbook exit code (0 = success)
        - ansibleStdout: Standard output from playbook
        - ansibleStderr: Standard error from playbook

        On Failure: Throws BpmnError("ANSIBLE_FAILED") caught by boundary event → compensation
      </documentation>
    </serviceTask>

    <!-- Element 3: Service Task - Dispatch Axon CORECOMMAND -->
    <serviceTask id="dispatchCommandTask"
                 name="Dispatch Axon CORECOMMAND"
                 flowable:delegateExpression="${dispatchAxonCommandTask}">
      <documentation>
        Dispatches Axon command (business logic trigger) using DispatchAxonCommandTask delegate.

        Required Variables (from process start):
        - tenantId: Tenant identifier for isolation (MANDATORY)
        - commandClassName: Set to ${coreCommandClassName} - FQN of Axon command class
        - constructorParameters: Set to ${coreCommandConstructorParameters} - Map of constructor arguments

        Command Dispatch:
        - Uses pure reflection pattern (Story 6.5 ARCH-001 remediation)
        - Enforces package whitelist (com.axians.eaf.*) and command class whitelist
        - Validates tenant context before dispatch

        On Success: Command dispatched to Axon CQRS infrastructure
        On Failure: Throws BpmnError caught by boundary event → compensation
      </documentation>
    </serviceTask>

    <!-- Element 4: Intermediate Catch Event - Wait for Axon Event -->
    <intermediateCatchEvent id="waitForEvent" name="Wait for Axon Event">
      <documentation>
        Pauses workflow execution until corresponding Axon event is published.

        Correlation via AxonEventSignalHandler (Story 6.3):
        - Two-step correlation query (business key → process instance ID)
        - Works around Flowable business key limitation
        - Event handler uses Flowable RuntimeService to signal waiting process

        Required Variables:
        - eventBusinessKey: Correlation key (typically aggregate ID or command ID)

        On Event Received: Process resumes and continues to POSTSCRIPT task
        Timeout: Configure via Flowable timer boundary event if needed (not in this template)
      </documentation>
      <messageEventDefinition messageRef="axonEventMessage" />
    </intermediateCatchEvent>

    <!-- Element 5: Service Task - Ansible POSTSCRIPT -->
    <serviceTask id="postscriptTask"
                 name="Ansible POSTSCRIPT"
                 flowable:delegateExpression="${runAnsiblePlaybookTask}">
      <documentation>
        Executes post-command automation Ansible playbook via SSH using RunAnsiblePlaybookTask delegate.

        Required Variables (from process start):
        - tenantId: Tenant identifier for isolation (MANDATORY)
        - playbookPath: Set to ${postscriptPlaybookPath} from process variables
        - inventory: (optional) Ansible inventory file
        - extraVars: (optional) Map of variables for playbook

        Output Variables (set by this task):
        - ansibleExitCode: Playbook exit code (0 = success)
        - ansibleStdout: Standard output from playbook
        - ansibleStderr: Standard error from playbook

        On Failure: Throws BpmnError("ANSIBLE_FAILED") caught by boundary event → compensation
      </documentation>
    </serviceTask>

    <!-- Element 6: Error Boundary Events (Compensation Triggers) -->

    <!-- Boundary Event: PRESCRIPT Failure -->
    <boundaryEvent id="prescriptError"
                   name="PRESCRIPT Failed"
                   attachedToRef="prescriptTask">
      <errorEventDefinition errorRef="processFailure" />
    </boundaryEvent>

    <!-- Boundary Event: CORECOMMAND Failure -->
    <boundaryEvent id="commandError"
                   name="CORECOMMAND Failed"
                   attachedToRef="dispatchCommandTask">
      <errorEventDefinition errorRef="processFailure" />
    </boundaryEvent>

    <!-- Boundary Event: POSTSCRIPT Failure -->
    <boundaryEvent id="postscriptError"
                   name="POSTSCRIPT Failed"
                   attachedToRef="postscriptTask">
      <errorEventDefinition errorRef="processFailure" />
    </boundaryEvent>

    <!-- Compensation Flow: Set Compensation Command Class -->
    <serviceTask id="setCompensationCommand"
                 name="Set Compensation Command"
                 flowable:delegateExpression="${setCommandTypeDelegate}">
      <documentation>
        Updates commandClassName and constructorParameters process variables for compensation flow.

        Pattern (Story 6.5): Generic DispatchAxonCommandTask requires explicit commandClassName
        update when dispatching different commands in error paths.

        Required Extension Fields:
        - targetCommandClassName: FQN from ${compensationCommandClassName} process variable
        - targetConstructorParameters: Comma-separated constructor parameter names

        Output: Sets commandClassName and constructorParameters for next task
      </documentation>
      <extensionElements>
        <flowable:field name="targetCommandClassName">
          <flowable:expression>${compensationCommandClassName}</flowable:expression>
        </flowable:field>
        <flowable:field name="targetConstructorParameters">
          <flowable:string>aggregateId,tenantId,cancellationReason,operator</flowable:string>
        </flowable:field>
      </extensionElements>
    </serviceTask>

    <!-- Compensation Flow: Dispatch Compensating Command -->
    <serviceTask id="compensationTask"
                 name="Dispatch Compensation Command"
                 flowable:delegateExpression="${dispatchAxonCommandTask}">
      <documentation>
        Dispatches compensating command to reverse the initial business transaction.

        Uses commandClassName and constructorParameters set by preceding SetCommandTypeDelegate task.

        Pattern: Compensating commands (e.g., CancelWidgetCreationCommand) reverse the state
        changes made by the original command, providing saga-like distributed transaction support.

        Tenant Validation: Validates tenant context matches command tenant (dual-layer enforcement)
        Error Handling: If compensation fails, process terminates in failure state
      </documentation>
    </serviceTask>

    <!-- Element 7: End Events -->

    <!-- Success Path: End Event -->
    <endEvent id="endSuccess" name="Process Completed Successfully" />

    <!-- Compensation Path: End Event -->
    <endEvent id="endCompensated" name="Process Compensated" />

    <!-- Sequence Flows: Happy Path -->
    <sequenceFlow id="flow1" sourceRef="start" targetRef="prescriptTask" />
    <sequenceFlow id="flow2" sourceRef="prescriptTask" targetRef="dispatchCommandTask" />
    <sequenceFlow id="flow3" sourceRef="dispatchCommandTask" targetRef="waitForEvent" />
    <sequenceFlow id="flow4" sourceRef="waitForEvent" targetRef="postscriptTask" />
    <sequenceFlow id="flow5" sourceRef="postscriptTask" targetRef="endSuccess" />

    <!-- Sequence Flows: Compensation Paths -->
    <sequenceFlow id="flow6" sourceRef="prescriptError" targetRef="setCompensationCommand" />
    <sequenceFlow id="flow7" sourceRef="commandError" targetRef="setCompensationCommand" />
    <sequenceFlow id="flow8" sourceRef="postscriptError" targetRef="setCompensationCommand" />
    <sequenceFlow id="flow9" sourceRef="setCompensationCommand" targetRef="compensationTask" />
    <sequenceFlow id="flow10" sourceRef="compensationTask" targetRef="endCompensated" />

  </process>

  <!-- Message Definition for Axon Event Correlation -->
  <message id="axonEventMessage" name="AxonEventReceived" />

  <!-- Error Definition for Process Failures -->
  <error id="processFailure" errorCode="PROCESS_FAILED" />

</definitions>
